<html>
    <head>
        <title>第一个three场景</title>
        <style>
            body {
                margin: 0;
            }
            canvas {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
    <body>
        <script src="/js/three.min.js"></script>
        <script>
            var scene = new THREE.Scene();
            function addFloor() {
                console.log(123);
                // 加入一个地面
                var groundGeometry = new THREE.PlaneGeometry(100, 100, 4, 4);
                var groundMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
                ground = new THREE.Mesh(groundGeometry, groundMaterial);
                // ground.rotation.x = 0.01;
                // ground.rotation.set(-0.5 * Math.PI, 0, 0); // 沿着 X轴旋转-90°
                scene.add(ground);
                // var floorGeom = new THREE.PlaneGeometry(100,100,20,20);
                // var floorMater = new THREE.MeshPhongMaterial();
                // floorMater.map = THREE.ImageUtils.loadTexture('/images/scence/grass.jpg');
                // //沿着(S)x,(T)y方向允许纹理重复自己
                // floorMater.map.wrapS = floorMater.map.wrapT = THREE.REpeatWrapping;
                // //material.map.repeat.set(repeatX,repeatY);repeatX：指定在x轴方向多久重复一次。repeatY：指定在y轴方向多久重复一次。
                // //如果设置为1，都不会重复。 如果设置<1，纹理就会被放大。 如果设置为负数，就会产生纹理镜像。
                // floorMater.map.repeat.set(10,10);
                // var floor = new THREE.Mesh(floorGeom,floorMater);
                // floor.receiveShadow = true;
                // floor.rotation.x = -0.5 * Math.PI;
                // scene.add(floor);

                //  /**
                //  * 创建矩形平面网格模型
                //  */
                // var geometry = new THREE.Geometry(); //声明一个空几何体对象
                // var p1 = new THREE.Vector3(0,0,0); //顶点1坐标
                // var p2 = new THREE.Vector3(80,0,0); //顶点2坐标
                // var p3 = new THREE.Vector3(80,80,0); //顶点3坐标
                // var p4 = new THREE.Vector3(0,80,0); //顶点4坐标
                // geometry.vertices.push(p1,p2,p3,p4); //顶点坐标添加到geometry对象
                // var normal = new THREE.Vector3( 0, 0, 1 ); //三角面法向量
                // var face0 = new THREE.Face3( 0, 1, 2, normal); //创建三角面0
                // var face1 = new THREE.Face3( 0, 2, 3, normal); //创建三角面1
                // geometry.faces.push( face0,face1 ); //三角面添加到几何体
                // var material=new THREE.MeshLambertMaterial({
                //     color:0x0000ff,//三角面颜色
                //     side:THREE.DoubleSide//两面可见
                // });//材质对象
                // var mesh=new THREE.Mesh(geometry,material);//网格模型对象
                // scene.add(mesh);//网格模型添加到场景中
            }
            addFloor();
            scene.background = new THREE.CubeTextureLoader()
                .setPath('/images/BlueSky/')
                .load(['posx.jpg', 'negx.jpg', 'posy.jpg', 'negy.jpg', 'posz.jpg', 'negz.jpg']);
            let axes = new THREE.AxisHelper(20); // 坐标轴
            scene.add(axes); // 场景添加坐标轴
            // scene.background=new THREE.Color(0xcfcfcf);
            var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            var renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            var geometry = new THREE.BoxGeometry(1, 1, 2); //width, height, depth
            var material = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true }); //把wireframe设为false显示面
            var cube = new THREE.Mesh(geometry, material);
            scene.add(cube);
            camera.position.z = 5;
            var animate = function () {
                requestAnimationFrame(animate);
                cube.rotation.x += 0.01;
                cube.rotation.y += 0.01;
                ground.rotation.x += 0.01;
                ground.rotation.y += 0.01;
                renderer.render(scene, camera);
            };
            animate();
            // var scene = new THREE.Scene();
            // scene.background = new THREE.Color(0xcfcfcf);
            // var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            // var renderer = new THREE.WebGLRenderer();
            // renderer.setSize(window.innerWidth, window.innerHeight);
            // document.body.appendChild(renderer.domElement);
            // var geometry = new THREE.BoxGeometry(1, 1, 2);//width, height, depth
            // var material = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });//把wireframe设为false显示面
            // var cube = new THREE.Mesh(geometry, material);
            // scene.add(cube);
            // camera.position.z = 5;

            // //箭头模块
            // //来自原点的方向。必须是单位向量
            // var dir = new THREE.Vector3(0, 10, 0);

            // // 规格化方向向量(转换为长度为1的向量)
            // dir.normalize();

            // // 箭头开始的点
            // var origin = new THREE.Vector3(0, 0, 0);

            // // 箭头的长度。默认值为1
            // var length = 3;

            // // 用于定义颜色的十六进制值。默认值为0xffff00
            // var hex = 0xffff00;

            // // 箭头的长度。默认值为0.2 *length
            // var headLength = 0.5;

            // // 箭头宽度的长度。默认值为0.2 * headLength。
            // var headWidth = 0.2;

            // // 箭头显示助手
            // var arrowHelper = new THREE.ArrowHelper(dir, origin, length, hex,headLength,headWidth);
            // scene.add(arrowHelper);

            // // 坐标轴模块
            // var size =3;// - （可选）表示轴的线的大小。默认值为1
            // var axesHelper = new THREE.AxesHelper( size );
            // scene.add( axesHelper );

            // var animate = function () {
            //     requestAnimationFrame(animate);
            //     cube.rotation.x += 0.01;
            //     arrowHelper.rotation.z += 0.02;
            //     axesHelper.rotation.y+=0.01;
            //     renderer.render(scene, camera);
            // };
            // animate();
            // var renderer;
            // var scene;
            // var camera;
            // var control;
            // var camControl;
            // function init() {
            //     scene = new THREE.Scene();
            //     camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
            //     camera.position.x = 15;
            //     camera.position.y = 6;
            //     camera.position.z = 15;
            //     camera.lookAt(scene.position);
            //     renderer = new THREE.WebGLRenderer();
            //     renderer.setClearColor(0x000000, 1.0);
            //     renderer.setSize(window.innerWidth, window.innerHeight);
            //     renderer.shadowMapEnabled = true;
            //     var spotLight = new THREE.SpotLight();
            //     spotLight.position.set(0, 80, 30);
            //     spotLight.castShadow = true;
            //     scene.add(spotLight);
            //     document.body.appendChild(renderer.domElement);
            //     addFloor();
            //     // addRail();
            //     // addSphere();
            //     render();
            // }
            // function addFloor() {
            //     var floorGeom = new THREE.PlaneGeometry(100,100,20,20);
            //     var floorMater = new THREE.MeshPhongMaterial();
            //     floorMater.map = THREE.ImageUtils.loadTexture('/images/scence/grass.jpg');
            //     //沿着(S)x,(T)y方向允许纹理重复自己
            //     floorMater.map.wrapS = floorMater.map.wrapT = THREE.REpeatWrapping;
            //     //material.map.repeat.set(repeatX,repeatY);repeatX：指定在x轴方向多久重复一次。repeatY：指定在y轴方向多久重复一次。
            //     //如果设置为1，都不会重复。 如果设置<1，纹理就会被放大。 如果设置为负数，就会产生纹理镜像。
            //     floorMater.map.repeat.set(10,10);
            //     var floor = new THREE.Mesh(floorGeom,floorMater);
            //     floor.receiveShadow = true;
            //     floor.rotation.x = -0.5 * Math.PI;
            //     scene.add(floor);
            // }
            // function addRail() {
            //     var cylinderGeometry = new THREE.CylinderGeometry(0.1, 0.1,15,50,50);
            //     var cylinderMaterial = new THREE.MeshPhongMaterial({color:0xeeeeee});
            //     var cylinder = new THREE.Mesh(cylinderGeometry,cylinderMaterial);
            //     cylinder.position.set(1,5,1);
            //     cylinder.rotation.x = '15';
            //     cylinder.rotation.y = '-57.8';
            //     cylinder.rotation.z = '-14.85';
            //     cylinder.name = 'cylinder';
            //     scene.add(cylinder);
            // }
            // function addSphere() {
            //     var sphereGeometry = new THREE.SphereGeometry(0.8, 25, 25);
            //     var sphereMaterial = new THREE.MeshBasicMaterial({specular: '#a9fcff',emissive: '#006063',shininess: 10});
            //     var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            //     sphere.position.set(7,0.8,-1);
            //     sphere.castShadow = true;
            //     var texture = new THREE.ImageUtils.loadTexture("http://10.1.26.29:84/assets/football.jpg");
            //     sphereMaterial.map = texture;
            //     sphere.name = 'sphere';
            //     scene.add(sphere);
            // }
            // var step = 0;
            // function render() {
            //     var sphere = scene.getObjectByName('sphere');
            //     renderer.render(scene, camera);
            //     camera.lookAt(sphere.position);
            //     step += 0.02;
            //     sphere.position.x = 0 + ( 10 * (Math.cos(step)));
            //     sphere.position.y = 0.75 * Math.PI / 2 + ( 6.5 * Math.abs(Math.sin(step)));
            //     sphere.rotation.z += 0.03;
            //     var x = camera.position.x;
            //     var z = camera.position.z;
            //     camera.position.x = x * Math.cos(0.015) + z * Math.sin(0.015);
            //     camera.position.z = z * Math.cos(0.015) - x * Math.sin(0.015);
            //     requestAnimationFrame(render);
            // }
            // function onResize() {
            //     camera.aspect = window.innerWidth / window.innerHeight;
            //     camera.updateProjectionMatrix();
            //     renderer.setSize(window.innerWidth, window.innerHeight);
            // }
            // window.onload = init;
            // window.addEventListener('resize', onResize, false);
        </script>
    </body>
</html>
