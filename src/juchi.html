<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - layers</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
        <link type="text/css" rel="stylesheet" href="main.css" />
        <style>
            body,
            html {
                background-color: #f0f0f0;
                color: #444;
                height: 100%;
            }
            a {
                color: #08f;
            }
            #container {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
    <body>
        <div id="container">
            <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> Click on a sphere to toggle bloom<br />By
            <a href="http://github.com/Temdog007" target="_blank" rel="noopener">Temdog007</a>
        </div>

        <script type="x-shader/x-vertex" id="vertexshader">

            varying vec2 vUv;

            void main() {

            	vUv = uv;

            	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

            }
        </script>

        <script type="x-shader/x-fragment" id="fragmentshader">

            uniform sampler2D baseTexture;
            uniform sampler2D bloomTexture;

            varying vec2 vUv;

            void main() {

            	gl_FragColor = ( texture2D( baseTexture, vUv ) + vec4( 1.0 ) * texture2D( bloomTexture, vUv ) );

            }
        </script>

        <script type="module">
            import * as THREE from '/build/three.module.js';

            import { EffectComposer } from '/js/jsm/postprocessing/EffectComposer.js';
            import { RenderPass } from '/js/jsm/postprocessing/RenderPass.js';
            import { ShaderPass } from '/js/jsm/postprocessing/ShaderPass.js';
            import { CopyShader } from '/js/jsm/shaders/CopyShader.js';
            import { FXAAShader } from '/js/jsm/shaders/FXAAShader.js';

            let camera, scene, renderer, clock, group, container;

            let composer1, composer2, fxaaPass;

            init();
            animate();

            function init() {
                container = document.getElementById('container');

                camera = new THREE.PerspectiveCamera(45, container.offsetWidth / container.offsetHeight, 1, 2000);
                camera.position.z = 500;

                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xffffff);
                scene.fog = new THREE.Fog(0xcccccc, 100, 1500);

                clock = new THREE.Clock();

                //

                const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444);
                hemiLight.position.set(0, 1000, 0);
                scene.add(hemiLight);

                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(-3000, 1000, -1000);
                scene.add(dirLight);

                //

                group = new THREE.Group();

                const geometry = new THREE.TetrahedronGeometry(10);
                const material = new THREE.MeshStandardMaterial({ color: 0xee0808, flatShading: true });

                for (let i = 0; i < 100; i++) {
                    const mesh = new THREE.Mesh(geometry, material);

                    mesh.position.x = Math.random() * 500 - 250;
                    mesh.position.y = Math.random() * 500 - 250;
                    mesh.position.z = Math.random() * 500 - 250;

                    mesh.scale.setScalar(Math.random() * 2 + 1);

                    mesh.rotation.x = Math.random() * Math.PI;
                    mesh.rotation.y = Math.random() * Math.PI;
                    mesh.rotation.z = Math.random() * Math.PI;

                    group.add(mesh);
                }

                scene.add(group);

                //

                renderer = new THREE.WebGLRenderer();
                renderer.autoClear = false;
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(container.offsetWidth, container.offsetHeight);
                container.appendChild(renderer.domElement);

                //

                const renderPass = new RenderPass(scene, camera);

                //

                fxaaPass = new ShaderPass(FXAAShader);
                const copyPass = new ShaderPass(CopyShader);

                composer1 = new EffectComposer(renderer);
                composer1.addPass(renderPass);
                composer1.addPass(copyPass);

                //

                const pixelRatio = renderer.getPixelRatio();

                fxaaPass.material.uniforms['resolution'].value.x = 1 / (container.offsetWidth * pixelRatio);
                fxaaPass.material.uniforms['resolution'].value.y = 1 / (container.offsetHeight * pixelRatio);

                console.log(1 / (container.offsetWidth * pixelRatio));
                composer2 = new EffectComposer(renderer);
                composer2.addPass(renderPass);
                composer2.addPass(fxaaPass);

                //

                window.addEventListener('resize', onWindowResize);
            }

            function onWindowResize() {
                camera.aspect = container.offsetWidth / container.offsetHeight;
                camera.updateProjectionMatrix();

                renderer.setSize(container.offsetWidth, container.offsetHeight);
                composer1.setSize(container.offsetWidth, container.offsetHeight);
                composer2.setSize(container.offsetWidth, container.offsetHeight);

                const pixelRatio = renderer.getPixelRatio();

                fxaaPass.material.uniforms['resolution'].value.x = 1 / (container.offsetWidth * pixelRatio);
                fxaaPass.material.uniforms['resolution'].value.y = 1 / (container.offsetHeight * pixelRatio);
            }

            function animate() {
                requestAnimationFrame(animate);

                const halfWidth = container.offsetWidth / 2;

                group.rotation.y += clock.getDelta() * 0.1;

                renderer.setScissorTest(true);

                renderer.setScissor(0, 0, halfWidth - 1, container.offsetHeight);
                composer1.render();

                renderer.setScissor(halfWidth, 0, halfWidth, container.offsetHeight);
                composer2.render();

                renderer.setScissorTest(false);
            }
        </script>
    </body>
</html>
